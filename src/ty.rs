use std::hash::{ Hash, Hasher };
use std::any::TypeId;

/// meta-data about an arbitrary type
#[derive(Debug, Clone)]
pub struct Type
{
    /// store the type ID
    id: Id,
    /// size, in bytes, of the type
    size: usize,
    /// alignment, in bytes, of the type
    align: usize,
    /// drop logic needs to be cached to because we're working with u8*
    drop: DropFn,
}

/// the numerical identifier of a type, whether generated at
/// compile or runtime
#[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq)]
enum Id
{
    /// type id is generated by rust for a concrete type
    Static(TypeId),
    /// type id is generated by the user at runtime, for scripting
    /// languages
    Dynamic(u64)
}

/// pointer to the drop in place function for a type, when it is
/// represented as a void*
type DropFn = unsafe fn(*mut u8);

impl Type
{
    /// get the type meta given a compile-time type
    pub fn of<T: 'static>() -> Self
    {
        unsafe fn drop_ptr<T>(ptr: *mut u8)
        {
            ptr.cast::<T>().drop_in_place()
        }

        Self
        {
            id: Id::Static(TypeId::of::<T>()),
            size: std::mem::size_of::<T>(),
            align: std::mem::align_of::<T>(),
            drop: drop_ptr::<T>,
        }
    }

    /// is this type static(a concrete rust type known at compile time)
    ///
    /// opposite of `is_dynamic`
    pub fn is_static(&self) -> bool
    {
        match self.id
        {
            Id::Static(_) => true,
            _ => false,
        }
    }

    /// is this type dynamic(type resolved at runtime, usually through a scripting
    /// solution)
    ///
    /// opposite of `is_static`
    pub fn is_dynamic(&self) -> bool
    {
        !self.is_static()
    }

    /// get the numerical identifier of this type, regardless of
    /// whether its runtime or dynamic
    pub fn id(&self) -> u64
    {
        match self.id
        {
            Id::Static(ty) => unsafe { *(&ty as *const TypeId as *const u64) },
            Id::Dynamic(id) => id,
        }
    }

    /// get the size, in bytes, of the type
    pub fn size(&self) -> usize
    {
        self.size
    }

    /// get the alignment, in bytes, of the type
    pub fn alignment(&self) -> usize
    {
        self.align
    }

    /// drop in place a void pointer, assuming the pointer
    /// points to the same type referenced by this `TypeMeta`
    pub unsafe fn drop(&self, ptr: *mut u8)
    {
        (self.drop)(ptr)
    }
}

impl PartialOrd for Type
{
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering>
    {
        Some(self.cmp(other))
    }
}

impl PartialEq for Type
{
    fn eq(&self, other: &Self) -> bool
    {
        self.id == other.id
    } 
}

impl Ord for Type
{
    fn cmp(&self, other: &Self) -> std::cmp::Ordering
    {
        self.align
            .cmp(&other.align)                      // compare by alignment
            .reverse()                              // reverse to maximize space
                                                    // start with greatest alignment ->
                                                    // only space wasted is `abs(greatest_align - align_of(EntId))`
            .then_with(|| self.id.cmp(&other.id))   // tie breaker via ID
    }
}

impl Eq for Type { }

impl Hash for Type
{
    fn hash<H: Hasher>(&self, state: &mut H)
    {
        state.write_u64(self.id())
    }
}