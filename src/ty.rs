use std::hash::{ Hash, Hasher };
use std::borrow::Borrow;

/// meta-data about an arbitrary type
#[derive(Debug, Clone)]
pub struct Type
{
    /// store the type ID
    id: TypeId,
    /// size, in bytes, of the type
    size: usize,
    /// alignment, in bytes, of the type
    align: usize,
    /// drop logic needs to be cached to because we're working with u8*
    drop: DropFn,
}

/// the numerical identifier of a type, whether generated at
/// compile or runtime
#[derive(Debug, Clone, Copy, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub enum TypeId
{
    /// type id is generated by rust for a concrete type
    Static(u64),
    /// type id is generated by the user at runtime, for scripting
    /// languages
    Dynamic(u64)
}

/// pointer to the drop in place function for a type, when it is
/// represented as a void*
type DropFn = unsafe fn(*mut u8);

impl Type
{
    /// get the type meta given a compile-time type
    pub fn of<T: 'static>() -> Self
    {
        unsafe fn drop_ptr<T>(ptr: *mut u8)
        {
            ptr.cast::<T>().drop_in_place()
        }

        fn id<U: 'static>() -> u64
        {
            unsafe
            {
                *(
                    &std::any::TypeId::of::<U>()    // get type id...
                    as *const std::any::TypeId      // ptr to type id...
                    as *const u64                   // cheat our way in to inner id
                )
            }
        }

        Self
        {
            id: TypeId::Static(id::<T>()),
            size: std::mem::size_of::<T>(),
            align: std::mem::align_of::<T>(),
            drop: drop_ptr::<T>,
        }
    }

    /// get the identifier of this type
    pub fn id(&self) -> TypeId
    {
        self.id
    }

    /// get the size, in bytes, of the type
    pub fn size(&self) -> usize
    {
        self.size
    }

    /// get the alignment, in bytes, of the type
    pub fn alignment(&self) -> usize
    {
        self.align
    }

    /// drop in place a void pointer, assuming the pointer
    /// points to the same type referenced by this `TypeMeta`
    pub unsafe fn drop(&self, ptr: *mut u8)
    {
        (self.drop)(ptr)
    }
}

impl TypeId
{
    /// get the type ID a compile-time type
    pub fn of<T: 'static>() -> Self
    {
        use std::any::TypeId;

        /// union to transmute TypeId to an integer
        union Id
        {
            typ: TypeId,
            num: u64
        }

        Self::Static(unsafe { Id { typ: TypeId::of::<T>() }.num })
    }
}

impl PartialOrd for Type
{
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering>
    {
        Some(self.cmp(other))
    }
}

impl PartialEq for Type
{
    fn eq(&self, other: &Self) -> bool
    {
        self.id == other.id
    } 
}

impl Ord for Type
{
    fn cmp(&self, other: &Self) -> std::cmp::Ordering
    {
        self.align
            .cmp(&other.align)                      // compare by alignment
            .reverse()                              // reverse to maximize space
                                                    // start with greatest alignment ->
                                                    // only space wasted is `abs(greatest_align - align_of(EntId))`
            .then_with(|| self.id.cmp(&other.id))   // tie breaker via ID
    }
}

impl Eq for Type { }

impl PartialOrd<TypeId> for Type
{
    fn partial_cmp(&self, other: &TypeId) -> Option<std::cmp::Ordering>
    {
        self.id().partial_cmp(other)
    }
}

impl PartialEq<TypeId> for Type
{
    fn eq(&self, other: &TypeId) -> bool
    {
        self.id().eq(other)
    }
}

impl Borrow<TypeId> for Type
{
    fn borrow(&self) -> &TypeId
    {
        &self.id
    }
}

impl Hash for Type
{
    fn hash<H: Hasher>(&self, state: &mut H)
    {
        let id = match self.id
        {
            TypeId::Static(id) => id,
            TypeId::Dynamic(id) => id
        };
        state.write_u64(id)
    }
}